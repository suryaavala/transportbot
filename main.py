import os, sys, json, requests
from flask import Flask, request
import apiai
from config import *
from threadsettings import *

app = Flask(__name__)

# An endpoint to ApiAi, an object used for making requests to a particular agent.
ai = apiai.ApiAI(CLIENT_ACCESS_TOKEN)


@app.route('/', methods=['GET'])
def verify():
    # when the endpoint is registered as a webhook, it must echo back
    # the 'hub.challenge' value it receives in the query arguments
    if request.args.get("hub.mode") == "subscribe" and request.args.get("hub.challenge"):
        if not request.args.get("hub.verify_token") == VERIFY_TOKEN:
            return "Verification token mismatch", 403
        return request.args["hub.challenge"], 200
    return "Welcome", 200


@app.route('/', methods=['POST'])
def fb_webhook():
    data = request.get_json()

    if data["object"] == "page":
        for entry in data["entry"]:
            for messaging_event in entry["messaging"]:
                if messaging_event.get("message"):  # Checking if the messaging even contains a message field.

                    sender_id = messaging_event["sender"]["id"]  # the facebook ID of the person sending you the message
                    recipient_id = messaging_event["recipient"]["id"]  # the recipient's ID, which should be your page's facebook ID
                    message_text = messaging_event["message"]["text"]  # the message's text
                    send_message_staggered(sender_id, parse_natural_text(message_text))  # Sending a response to the user.
        return "ok", 200


# Sending a message back through Messenger.
def send_message(sender_id, message_text):
    r = requests.post("https://graph.facebook.com/v2.6/me/messages",
                      params={"access_token": PAGE_ACCESS_TOKEN},
                      headers={"Content-Type": "application/json"},
                      data=json.dumps({
                          "recipient": {"id": sender_id},
                          "message": {"text": message_text}
                      }))


# Takes a string of natural language text, passes it to ApiAI, returns a
# response generated by an ApiAI bot.
def parse_natural_text(user_text):
    # Sending a text query to our bot with text sent by the user.
    request = ai.text_request()
    request.query = user_text

    # Receiving the response.
    response = json.loads(request.getresponse().read().decode('utf-8'))
    responseStatus = response['status']['code']
    if (responseStatus == 200):
        # Sending the textual response of the bot.
        return (response['result']['fulfillment']['speech'])

    else:
        return ("Sorry, I couldn't understand that question")

        # NOTE:
        # At the moment, all messages sent to ApiAI cannot be differentiated,
        # they are processed as a single conversation regardless of concurrent
        # conversations. We need to perhaps peg a session id (ApiAI) to a recipient
        # id (Messenger) to fix this.

        # request.session_id = "<SESSION ID, UNIQUE FOR EACH USER>"


# Sends the message in segments delimited by a period.
def send_message_staggered(sender_id, message_text):
    sentenceDelimiter = ". "
    messages = message_text.split(sentenceDelimiter)

    for message in messages:
        send_message(sender_id, message)


if __name__ == "__main__":
    app.run()
